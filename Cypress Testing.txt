To install npm install cypress --save-dev
npm run dev
npx cypress open

To navigate to our application using PORT
cy.visit("localhost URL")

To get the particular element from HTML
cy.get("h1")

To check whether the text inside h1 is correct or not
cy.get("h1").contains("Text")

Command Chaining:-
Command chaining is nothing but writing commands one another  for example,
cy.get().should("to check exist or not").contain();

Note:- Don't use classes or IDs on DOM elements for testing.

only():-
What if we have multiple tests and if want to run only one or a specific once?
By using it.only() we can run that particular test cases

Example:-
  it.only("the features on the home page are correct", () => {
    cy.visit("http://localhost:3000")
  })


Example:- If we have array of elements 
<dt><>0</></dt>
<dt><>1</></dt>
<dt><>2</></dt>

  it.only("the features on the home page are correct", () => {
    cy.visit("http://localhost:3000")
    cy.get("dt").eq(1).contains("25+ Lessons")
  })

Here we are fetching "dt" elements with the index 1
Note: .contains() is the case-sensitive


How to Test Forms?
cy.get('[data-test="hero-heading"] > .block') are generated by the cypress which is difficult to read and understand.

Creating Cypress Custom Commands:-
In Support file > commands.ts file create a custom commands
Cypress.Commands.add("getByData", (selector) => {
  return cy.get(`[data-test=${selector}]`)
})

Now create a new file
describe("Newsletter Subscribe Form", () => {
  beforeEach(() => {
    cy.visit("http://localhost:3000")
  })
  it("allows users to subscribe to the email list", () => {
    cy.getByData("email-input").type("akhil@gmail.com")
    cy.getByData("submit-button").click()
    cy.getByData("success-message").should("exist").contains("akhil@gmail.com")
  })
  it("does not allow invalid email address", () => {
    cy.getByData("email-input").type("akhil")
    cy.getByData("submit-button").click()
    cy.getByData("success-message").should("not.exist")
  })
  it("does NOT allow already subscribed email addresses", () => {
    cy.getByData("email-input").type("john@example.com")
    cy.getByData("submit-button").click()
    cy.getByData("server-error-message")
      .should("exist")
      .contains("already exists. Please use a different email address.")
  })
})


Note:- getByData is the custom command which pass the string  as argument to cammand.ts file.

How to test multiple pages?
Organizing tests by using "context()" which is used to identify easily by the programmer by giving some description.

Example:-
describe("home page", () => {
  context("hero section", () => {
    it("the h1 contains the correct text", () => {
      cy.visit("http://localhost:3000")
      cy.get("h1").contains("Testing Next.js Applications with Cypress")
    })

    it.only("the features on the home page are correct", () => {
      cy.visit("http://localhost:3000")
      cy.get("dt").eq(1).contains("25+ Lessons")
    })
  })
})

Manual Testing:-
Manual testing involves someone, typically QA, physically interacting with an application. Manual testing is often very time-consuming as it requires someone repeating the same tasks over and over again, something that computers are incredibly good at.

Automated Testing:-
As more and more teams adopt CI/CD systems and want to push to production multiple times a day, automated tests are the only way to scale such demand.
A movement is started within the software dev is that "shift left".
Shift left is nothing but the developers are increasingly becoming more involved in testing.

What is the testing pyramid?
1. E2E
2. Integration
3. Unit       

How to write a test?
One pattern is the AAA (Arrange-Act-Assert) pattern, which encourages the organization of the test code in a way that allows the most readability and flexibility.

1. Arrange
In step one, the Arrange step, you have to perform some setup for your test. For example, in the case of a Cypress end-to-end test, you need to tell Cypress to open the browser and navigate to the correct URL.

-> cy.visit("http://localhost:8888")

2. Act
In step two, the Act step, you perform some action. For example, in the case of a todo app, you want to test that you can add a single todo.

-> cy.get(".new-todo").type("Buy Milk{enter}")

3. Assert
Finally, in step three, you Assert. In this step, you assert that the thing you acted upon in step two did what you expected.

-> cy.get(".todo-list li").should("have.length", 1)

Cypress is build upon "Mocha". Each file will typically begin with a describe() function or a block.
Inside of describe function we have an it() block.
In this it block we are doing three things AAA(Arrange, Act, Assert).

Syntax:- 
describe("Description",()=> {
	it("Description", () => {
		...
	})
})

Since Cypress is running in the browser, it also has the ability to read and alter web traffic on the fly

Asynchronous nature of Cypress:-
1. Should not use variables in Cypress like,
const btn = cy.get("button")
button.click()

2. Cypress commands are asynchronous, Cypress code runs between each command to ensure everything is in order.

.then() in Cypress:-
To interact with subject directly .then() is usefull. It behaves same as promises in js but not as async and await.

cy.get("button").then(($btn) => {
  const cls = $btn.attr("class")

  // ...
})

.wrap() in Cypress:-
In the above example we have $btn which is jQuery object. By using .wrap() we can interact with it.

cy.get("button").then(($btn) => {
  const cls = $btn.attr("class")

  cy.wrap($btn).click().should("not.have.class", cls)
})


Waiting and Retry-Ability:-
Cypress will pause executing any commands when a page transition happens until the new page has fully loaded.
Cypress will handle a automatic waiting

Aliases (.as()):-
In cypress, aliases are used to reference elements, requests or intercepts.

Example:-
cy.get("table").find("tr").as("rows")
This will get the <table> HTML element, find all of the <tr> elements, and allow us to reference them as @rows throughout our tests.

We can access our alias using cy.get() by adding the @ character before our alias name, like so

cy.get("@rows")


Database Initialization & Seeding in Cypress:-
Different ways to create data for tests
1. Using the UI to create the data we needed.
2. Make queries to the database to create the data you need.
3. Making API calls to your backend to provision data.
4. Creating database seeds with factory scripts.

Intercepting Network Requests:-
Intercepting server requests:-
cy.intercept("POST","/users")

Intercepting any POST req to the /users route. We can also alias an intercept to perform actions like .wait(), .later(). 

Example:-
cy.intercept("POST","/users").as("signup")
cy.wait("@signup")

Overriding existing intercept:-
We can also intercept other intercepts and then provide mocked data using a fixture. 
Example:-
cy.intercept("GET", "/transactions/public*", {
  // ...
  fixture: "public-transactions.json",
}).as("mockedPublicTransactions")


Changing Headers:-
We can also change the headers by using the intercept.

Example:-
cy.intercept("GET", "/transactions/public*", {
  headers: {
    "X-Powered-By": "Express",
    Date: new Date().toString(),
  },
})

Modifying Response Data:-
We can also modify the response data by using the callback function in intercept()

Example:-
cy.intercept("POST", "/bankaccounts", (req) => {
  const { body } = req
  req.continue((res) => {
    res.body.data.listBankAccount = []
  })
})

API and Integration Tests:-
Example:-
context("GET /users", () => {
  it("gets a list of users", () => {
    cy.request("GET", "/users").then((response) => {
      expect(response.status).to.eq(200)
      expect(response.body.results).length.to.be.greaterThan(1)
    })
  })
})

Cypress Methods:-
its():-
It is used when you want to get the property off of something.
cy.wrap(["Wai Yan", "Yu"]).its(1).should("eq", "Yu") // true
Where the array index value() is "Yu" it can be accessed by using its() method by using an index value.

cy.wrap({ age: 52 }).its("age").should("eq", 52) // true
Objects can be accessed by the key using its() method.

invoke() Method:-
Which allows us to call JS functions like slice method given below. In the below code, we get the array of results for whichW we are applying the slice method.
Example:-

  cy.wait("@publicTransactions")
  .its("response.body.results")
  .invoke("slice", 0, 5)

request() Method:-
It is used to make HTTP requests anytime in tests and also perform expectations.
Example:-
cy.request("POST", "http://localhost:8888/users/admin", { name: "Jane" }).then(
  (response) => {
    // response.body is automatically serialized into JSON
    expect(response.body).to.have.property("name", "Jane") // true
  }
)

within() Method:-
It is useful when working with particular group of elements such as <form>.
it("ensures the section lesson exists", () => {
  cy.getBySel("section-steps").within(() => {
    cy.getBySel("lesson-complete-0").should("exist")
  })
})

Here "section-steps" is a parent, where "lesson-complete-0" is child within the parent.

Using Data to Build Dynamic Tests
Data-Driven Tests:-
We can hard code the data as below
cy.get("username").type("jdoe")
cy.get("password").type("password123")

else, by using fixture() method 
Syntax:-
fixture(filepath)

Example:-
cy.fixture("users.json").as("usersData")

cy.get("username").type(usersData[0].username)
cy.get("password").type(usersData[0].password)

Lesson 1:- Write your first Cypress test
describe('template spec', () => {
  it('passes', () => {
    cy.visit('http://localhost:3001')

    cy.get('[data-test="username"]').type('standard_user')
    cy.get('[data-test="password"]').type('secret_sauce')

    cy.get('[data-test="login-button"]').click()
    cy.location('pathname').should('eq', '/inventory.html')

    cy.get('.inventory_list')
      .should('be.visible')
      .find('.inventory_item')
      .should('have.length.greaterThan', 3)
  })
})

Lesson 2: Confirm the lowest price in the store
    cy.get('.inventory_list')
      .should('be.visible')
      .find('.inventory_item_price')
      .should('have.length.greaterThan', 3)

      .then(($list) => Cypress._.map($list, 'innerText'))
      .then(console.log)
      .then((prices) => prices.map((p) => p.slice(1)))
      .then(console.log)
      .then((strings) => strings.map(Number))
      .then(console.log)
      .then((prices) => Cypress._.min(prices))
      .should('equal', 7.99)

-> By installing cypress-map we can make mapping easy
-> instead of console.log we can use 'print'.
-> .mapInvoke() is used for JS operations

    cy.get('.inventory_list')
      .should('be.visible')
      .find('.inventory_item_price')
      .should('have.length.greaterThan', 3)

      .map('innerText')
      .print('strings %o')
      .mapInvoke('slice', 1)
      .print('without $ %o')
      .map(Number)
      .print('numbers %o')
      .apply(Cypress._.min)
      .should('equal', 7.99)


Lesson 3: Confirm the sorted prices





























